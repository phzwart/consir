import numpy as np
from scipy.spatial import KDTree

class PoissonDiskSamplerWithExisting(object):
    """
    A class to generate samples using Poisson Disk Sampling within a specified domain,
    constrained by an existing set of points.

    Attributes:
        domain (list of tuples): Boundaries for each dimension in the domain.
        r (float): Minimum distance between samples.
        k (int): Maximum number of attempts to generate a new sample around each existing sample.
        existing_points (ndarray): Array of points that already exist in the domain and must be respected.
        existing_labels (ndarray): Array of labels corresponding to existing points.
        wrap (bool): Whether to use wrap-around edges for tiling.
    """

    def __init__(self, domain, r, existing_points=None, existing_labels=None,
                 k=60, symmetry_operators=None, wrap=False):
        """
        Initializes the PoissonDiskSamplerWithExisting with the given domain, minimum distance, and optional parameters.

        Args:
            domain (list of tuples): Boundaries for each dimension in the domain, as (min, max) pairs.
            r (float): Minimum distance between samples.
            existing_points (ndarray, optional): Array of pre-existing points. Defaults to None.
            existing_labels (ndarray, optional): Array of labels for pre-existing points. Defaults to None.
            k (int, optional): Maximum number of attempts to generate a new sample. Defaults to 60.
            symmetry_operators (list of callables, optional): List of symmetry operations to apply to the points. Each operator is a function that takes a point and returns a transformed point.
            wrap (bool, optional): Whether to use wrap-around edges for tiling. Defaults to False.
        """
        self.domain = np.array(domain)
        self.r = r
        self.k = k
        self.dimensions = len(domain)
        self.cell_size = r / np.sqrt(self.dimensions)
        self.existing_points = existing_points
        self.symmetry_operators = symmetry_operators if symmetry_operators is not None else []
        self.wrap = wrap

        if existing_points is not None:
            self.samples = existing_points.tolist()
            self.idx_to_point = {i: pt for i, pt in enumerate(existing_points)}
            self.kdtree = KDTree(existing_points)
            self.labels = existing_labels if existing_labels is not None else np.array(
                ["existing"] * len(existing_points))
        else:
            self.samples = []
            self.idx_to_point = {}
            self.kdtree = None
            self.labels = np.array([])

    def generate_points_around(self, point):
        """
        Generates potential points around a given sample within the allowed radius.

        Args:
            point (array-like): The point around which to generate new points.

        Returns:
            ndarray: Array of new points around the given point.
        """
        radius = np.sqrt(
            np.random.uniform(self.r ** 2, (2 * self.r) ** 2, self.k))
        directions = np.random.normal(0, 1, (self.k, self.dimensions))
        unit_vectors = directions / np.linalg.norm(directions, axis=1)[:, None]
        new_points = point + radius[:, None] * unit_vectors

        if self.wrap:
            # Apply wrap-around for each dimension with arbitrary bounds
            for dim in range(self.dimensions):
                min_bound, max_bound = self.domain[dim]
                new_points[:, dim] = (new_points[:, dim] - min_bound) % (
                            max_bound - min_bound) + min_bound

        return new_points

    def is_valid_point(self, point):
        """Optimized version of point validation."""
        if np.any(point < self.domain[:, 0]) or np.any(point >= self.domain[:, 1]):
            return False

        if self.kdtree is not None:
            if len(self.kdtree.query_ball_point(point, self.r)) > 0:
                return False

        if len(self.samples) > 0:
            # Vectorized distance calculation
            points = np.array(self.samples)
            if self.wrap:
                # Vectorized wrap-around distance calculation
                diff = np.abs(point - points)
                domain_size = self.domain[:, 1] - self.domain[:, 0]
                wrapped_diff = np.minimum(diff, domain_size - diff)
                distances = np.sqrt(np.sum(wrapped_diff ** 2, axis=1))
            else:
                distances = np.sqrt(np.sum((point - points) ** 2, axis=1))
            
            if np.any(distances < self.r):
                return False

        return True

    def apply_symmetry(self, point):
        """
        Applies all symmetry operations to a point and returns a list of all resulting points.

        Args:
            point (array-like): The point to which symmetry operations are applied.

        Returns:
            list: A list of points generated by applying the symmetry operators.
        """
        symmetric_points = [point]
        for op in self.symmetry_operators:
            transformed_point = op(point)
            if transformed_point is not None:
                symmetric_points.append(transformed_point)
        return symmetric_points

    def sample(self, new_label=None, return_new_only=False):
        """
        Generates a sample of points using the Poisson Disk Sampling method, constrained by existing points.

        Args:
            new_label (int, optional): Label to assign to newly generated points. Defaults to None.
            return_new_only (bool, optional): Whether to return only the newly sampled points. Defaults to False.

        Returns:
            tuple: An array of sampled points and an array of labels.
        """
        if new_label is None:
            new_label = 0
            if len(self.labels) > 0:
                new_label = int(np.max(self.labels) + 1)

        if not self.samples:
            # If no existing points, initialize with a random point in the domain
            initial_point = np.random.uniform(self.domain[:, 0],
                                              self.domain[:, 1],
                                              self.dimensions)
            symmetric_points = self.apply_symmetry(initial_point)
            self.samples.extend(symmetric_points)
            for idx, point in enumerate(symmetric_points):
                self.idx_to_point[idx] = point
            self.labels = np.concatenate((self.labels, np.array(
                [new_label if new_label is not None else "new"] * len(
                    symmetric_points))))
            active_list = list(range(len(self.samples)))
        else:
            # Start with all existing points as active
            active_list = list(range(len(self.samples)))

        new_points = []
        new_labels = []

        # Update KDTree periodically (every 100 new points)
        update_frequency = 10
        points_since_update = 0
        
        while active_list:
            i = np.random.choice(active_list)
            current_point = self.samples[i]
            generated_points = self.generate_points_around(current_point)

            valid_found = False
            for point in generated_points:
                if self.is_valid_point(point):
                    symmetric_points = self.apply_symmetry(point)
                    for sym_point in symmetric_points:
                        if self.is_valid_point(sym_point):
                            self.samples.append(sym_point)
                            new_index = len(self.samples) - 1
                            self.idx_to_point[new_index] = sym_point
                            label = new_label if new_label is not None else "new"
                            self.labels = np.append(self.labels, label)
                            active_list.append(new_index)
                            new_points.append(sym_point)
                            new_labels.append(label)
                            valid_found = True
                    if valid_found:
                        break

            if not valid_found:
                active_list.remove(i)

            points_since_update += 1
            if points_since_update >= update_frequency:
                self.kdtree = KDTree(np.array(self.samples))
                points_since_update = 0

        if return_new_only:
            return np.array(new_points), np.array(new_labels)
        else:
            return np.array(self.samples), self.labels
